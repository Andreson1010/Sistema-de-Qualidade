PROJETO 6 — VERSIONAMENTO E CONTROLE DE DADOS EM PIPELINES CI/CD COM GITHUB ACTIONS E KUBERNETES

RESUMO
Este documento descreve como preparar o ambiente, treinar o modelo, construir a imagem Docker, publicar e acessar no Minikube e validar o pipeline CI/CD localmente com Act.

1. PRÉ-REQUISITOS
1.1 Ferramentas necessárias
- Docker Desktop instalado e em execução (mantenha a janela aberta)
- Kubectl instalado
- Minikube instalado
- Conda (ou Miniconda) instalado
- Git instalado
- Act instalado para testar GitHub Actions localmente

1.2 Validações rápidas
kubectl version --client
minikube version

1.3 Links úteis
Git: https://git-scm.com/
Act: https://nektosact.com/installation/index.html

2. CONFIGURAÇÃO DO AMBIENTE PYTHON
2.1 Criação e ativação do ambiente virtual
conda create --name pipep6 python=3.12
conda activate pipep6  (em bash/zsh)  |  no Windows PowerShell: conda activate pipep6

2.2 Instalação do pip e das dependências
conda install pip
pip install -r requirements.txt

3. TREINAMENTO DO MODELO
3.1 Execução do treinamento local
python treinamento/aivk_treina_modelo.py

4. BUILD DA IMAGEM DOCKER
4.1 Construção da imagem
Antes, certifique-se de que o Docker Desktop está ativo.
No diretório do projeto execute o comando:

```bash
docker build -t aivk-p6-app:latest .
```
4.2 Função do Comando
Este comando constrói uma imagem Docker com as seguintes características:
    - docker build: Comando para construir uma imagem Docker
    - -t aivk-p6-app:latest: Define o nome da imagem como aivk-p6-app com a tag latest
    - .: Especifica que o contexto de build é o diretório atual (onde está o Dockerfile)

4.3 O que acontece quando executado
    - Lê o Dockerfile: O Docker procura por um arquivo chamado Dockerfile no diretório atual
    - Executa as instruções: Segue as instruções do Dockerfile para criar a imagem
    - Cria a imagem: Gera uma imagem Docker com o nome aivk-p6-app:latest
    - Armazena localmente: A imagem fica disponível no Docker local para uso posterior

4.4 - Contexto do Projeto
Baseado no documento, este comando faz parte do passo 4.1 do pipeline de CI/CD, onde:
    - É executado após o treinamento do modelo (passo 3)
    - Prepara a imagem para ser carregada no Minikube (passo 5.2)
    - É usado no deploy do Kubernetes (passo 6)
A imagem construída contém a aplicação Python com o modelo treinado, pronta para ser executada em containers no ambiente Kubernetes.

4.2 Observação sobre arquitetura Apple Silicon
Ao usar o Act em Apple Silicon (Família M), pode ser necessário forçar a arquitetura linux/amd64.

5. MINIKUBE E CONTEXTO KUBERNETES
5.1 Início do cluster e confirmação do contexto. Execute o comando abaixo:

obs: Os comandos minikube start e kubectl config current-context podem ser executados 
em qualquer diretório (terminal home ou diretório do projeto), pois são comandos globais 
do sistema 

````bash
minikube start
kubectl config current-context   (deve retornar: minikube)
````
5.2. Função do comando 
    - minikube start : 
        - Função: Inicia um cluster Kubernetes LOCAL usando o Minikube.
        O que acontece:
        - Cria uma máquina virtual (VM) local
        - Instala e configura um cluster Kubernetes completo
        - Disponibiliza ferramentas como kubectl, dashboard, etc.
        - Permite executar aplicações Kubernetes localmente sem precisar de um cluster real

    - kubectl config current-context
        Função: Verifica qual contexto Kubernetes está ativo no momento.
        O que acontece:
            - Mostra o nome do cluster/configuração atual
            - Confirma se o kubectl está apontando para o cluster correto
            - No caso do projeto, deve retornar minikube para confirmar que está usando o cluster local
5.3 - Contexto no Projeto
    Estes comandos fazem parte do passo 5.1 do pipeline, onde:
        - minikube start: Prepara o ambiente Kubernetes local
        - kubectl config current-context: Valida que o kubectl está configurado corretamente para usar o Minikube

5.4 Carga da imagem local no Minikube

````
minikube image load aivk-p6-app:latest
````

5.4.1 - Função do Comando(minikube image load aivk-p6-app:latest)
    Função: Carrega uma imagem Docker local para dentro do cluster Minikube.
    O que acontece quando executado:
        - Acessa a imagem local: O Minikube localiza a imagem aivk-p6-app:latest que foi construída anteriormente com docker build
        - Transfere para o cluster: Move a imagem do Docker local para dentro da VM do Minikube
        - Disponibiliza no Kubernetes: A imagem fica acessível para os pods do Kubernetes no cluster Minikube
    Por que é necessário?
        Isolamento: O Minikube roda em uma VM separada do sistema host
        Acesso: O Kubernetes dentro do Minikube não consegue acessar imagens do Docker host diretamente
        Deploy: Sem carregar a imagem, o Kubernetes não conseguiria encontrar a imagem para criar os pods
    Contexto no Projeto
        Este comando faz parte do passo 5.2 do pipeline, onde:
        É executado após construir a imagem Docker (passo 4.1)
        Prepara a imagem para ser usada no deploy do Kubernetes (passo 6)
        É essencial para que o deployment funcione corretamente

6. DEPLOY NO KUBERNETES
6.1 Aplicação dos manifestos
kubectl apply -f k8s/deployment.yaml
kubectl apply -f k8s/service.yaml
kubectl get pods


6.1.1. `kubectl apply -f k8s/deployment.yaml`

**Função**: Aplica o manifesto de deployment no cluster Kubernetes.

**O que acontece**:
- Lê o arquivo `k8s/deployment.yaml` que contém a configuração do deployment
- Cria ou atualiza os pods da aplicação no cluster
- Define quantas réplicas da aplicação devem rodar
- Especifica qual imagem Docker usar (`aivk-p6-app:latest`)
- Configura recursos, variáveis de ambiente, etc.

6.1.2. `kubectl apply -f k8s/service.yaml`

**Função**: Aplica o manifesto de service no cluster Kubernetes.

**O que acontece**:
- Lê o arquivo `k8s/service.yaml` que contém a configuração do service
- Cria um serviço que expõe os pods para acesso externo
- Define o tipo de serviço (ClusterIP, NodePort, LoadBalancer)
- Mapeia portas e configura load balancing entre os pods

6.1.3. `kubectl get pods`

**Função**: Lista todos os pods em execução no cluster.

**O que acontece**:
- Mostra o status atual de todos os pods
- Exibe informações como nome, status, reinicializações, idade
- Permite verificar se os pods estão rodando corretamente
- Útil para diagnóstico e monitoramento

6.1.4 Contexto no Projeto

Estes comandos fazem parte do **passo 6.1** do pipeline, onde:

1. **Deployment**: Cria os pods da aplicação
2. **Service**: Expõe a aplicação para acesso externo
3. **Verificação**: Confirma que tudo está funcionando

Fluxo Completo

```
kubectl apply -f k8s/deployment.yaml  → Cria os pods
kubectl apply -f k8s/service.yaml    → Expõe os pods
kubectl get pods                      → Verifica o status
```

Por que são importantes?

- **Deployment**: Gerencia o ciclo de vida dos pods (criação, atualização, rollback)
- **Service**: Permite acesso externo à aplicação
- **Monitoramento**: Verifica se a aplicação está funcionando corretamente

Após estes comandos, a aplicação estará rodando no Kubernetes e pronta para ser acessada 
via `minikube service aivk-p6-app-service`.

6.2 Acesso à aplicação

- Função do Comando (minikube service aivk-p6-app-service`)

**Função**: Abre automaticamente o navegador e acessa a aplicação que está rodando no cluster Minikube.

O que acontece quando executado:

1. **Localiza o serviço**: O Minikube encontra o serviço chamado `aivk-p6-app-service` no cluster
2. **Obtém a URL**: Recupera a URL de acesso ao serviço (geralmente algo como `http://192.168.49.2:30000`)
3. **Abre o navegador**: Automaticamente abre o navegador padrão apontando para essa URL
4. **Exibe a aplicação**: Mostra a interface da aplicação Python que está rodando no Kubernetes

Por que é necessário?

- **Acesso externo**: O Minikube roda em uma VM isolada, então precisa de uma forma de acessar a aplicação
- **Port forwarding**: O comando cria um túnel entre o host e o cluster Minikube
- **Facilidade**: Elimina a necessidade de descobrir manualmente o IP e porta do serviço

Contexto no Projeto

Este comando faz parte do **passo 6.2** do pipeline, onde:

- É executado após aplicar os manifestos Kubernetes (deployment e service)
- Permite testar se a aplicação está funcionando corretamente
- É o ponto final para validar que todo o pipeline funcionou

## O que você verá:

- **Navegador aberto**: Automaticamente abrirá uma nova aba
- **Aplicação rodando**: Mostrará a interface da aplicação Python
- **URL no terminal**: Também exibirá a URL para acesso manual

## Alternativa manual:

Se preferir não abrir o navegador automaticamente, você pode:
- Usar `minikube service aivk-p6-app-service --url` para apenas obter a URL
- Acessar manualmente a URL fornecida

Este comando é essencial para **validar que a aplicação está funcionando** e acessível externamente 
após todo o processo de build, deploy e configuração do Kubernetes.



7. GIT E INICIALIZAÇÃO DO REPOSITÓRIO

7.1 Configuração e primeiro commit

1. git config --global user.email "anderson.pinheiro1183@gmail.com"
    Configura globalmente o email do usuário Git
    Este email será usado em todos os commits futuros
    Aparece no histórico de commits como autor

2. git config --global user.name "aivoraq"
    Configura globalmente o nome do usuário Git
    Este nome será usado em todos os commits futuros
    Aparece no histórico de commits como autor
3. git init
    Inicializa um novo repositório Git no diretório atual
    Cria a pasta .git com toda a estrutura do Git
    Transforma o diretório em um repositório versionado
4. git add .
    Adiciona todos os arquivos do diretório atual ao "staging area"
    O ponto (.) significa "todos os arquivos"
    Prepara os arquivos para serem commitados
5. git commit -m "Versão inicial do Projeto meia-duzia"
    Cria o primeiro commit com todos os arquivos adicionados
    -m permite escrever a mensagem do commit diretamente
    "Versão inicial do Projeto meia-duzia" é a mensagem descritiva do commit
6. Sequência completa:

    Configura a identidade do usuário
    Inicializa o repositório Git
    Adiciona todos os arquivos ao staging
    Cria o primeiro commit com uma mensagem descritiva


8. TESTE DO CI/CD LOCAL COM ACT
8.1 Execução do fluxo local
act push

8.2 Observação para Apple Silicon
act push --container-architecture linux/amd64

9. CICLO DE ATUALIZAÇÃO
9.1 Atualização do código e execução do pipeline local
git add .
git commit -m "Atualização do projeto"
act push

9.2 Atualização da imagem no cluster local
minikube image load aivk-p6-app:latest
kubectl set image deployment/aivk-p6-app-deployment aivk-p6-app-container=aivk-p6-app:latest

10. DICAS DE VERIFICAÇÃO E DIAGNÓSTICO (TROUBLESHOOTING)
10.1 Verificação de pods com erro (CrashLoopBackOff)
kubectl get pods
kubectl describe pod <nome-do-pod>
kubectl logs <nome-do-pod>

10.2 Problemas comuns e soluções rápidas
- Imagem não encontrada: executar minikube image load aivk-p6-app:latest antes do deploy/atualização
- Contexto incorreto do kubectl: verificar com kubectl config current-context
- Docker inativo: abrir o Docker Desktop e aguardar a inicialização completa

11. LIMPEZA (OPCIONAL)
11.1 Desativação e remoção do ambiente
conda deactivate
conda remove --name pipep6 --all